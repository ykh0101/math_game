<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>公因數 & 公倍數 PK 賽 (V4.0 真·觸控版)</title>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f8ff;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            overflow-x: hidden;
            margin: 0; 
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .game-container {
            display: flex;
            flex-wrap: wrap; 
            justify-content: center;
            gap: 20px;
            padding: 20px;
            width: 100%;
            max-width: 1600px;
        }
        .controls {
            width: 100%;
            text-align: center;
            background: #fff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            margin-bottom: 20px;
        }
        .controls h2 {
            margin-top: 0;
            color: #005a9c;
        }
        #start-round-btn, #show-rules-btn {
            background-color: #28a745;
            color: white;
            font-size: 1.2em;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 5px;
        }
        #start-round-btn:hover, #show-rules-btn:hover {
            background-color: #218838;
        }
        .problem-type-display, .round-display, .round-config {
            font-size: 1.2em;
            margin: 10px 0;
            font-weight: bold;
        }
        #problem-type {
            color: #d9534f;
        }
        .player-zone {
            flex: 1; 
            min-width: 320px; 
            max-width: 600px; 
            background: #ffffff;
            border: 2px solid #b0e0e6;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .player-zone h3 {
            text-align: center;
            margin-top: 0;
            font-size: 1.8em;
            color: #007bff;
        }
        .problem-display {
            font-size: 1.4em;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            min-height: 40px;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            flex-wrap: wrap;
            gap: 10px;
            color: #333;
        }
        .problem-item {
            display: inline-flex;
            align-items: flex-end;
            position: relative;
            padding-right: 5px;
        }
        .problem-item .base {
            font-size: 1.5em;
            line-height: 1;
        }
        .problem-item .power {
            font-size: 0.8em;
            position: absolute;
            top: -0.5em;
            right: 0;
            line-height: 1;
        }
        .problem-item:not(:last-child)::after {
            content: '‧';
            position: absolute;
            right: -10px;
            bottom: 0;
            font-size: 1.2em;
            color: #666;
        }
        .problem-item .power.empty {
            width: 1em;
            height: 1em;
            border: 1px solid #ccc;
            background-color: #f0f0f0;
            display: inline-block;
            top: 0;
            right: 0;
        }
        .timer-display, .score-display {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 10px;
        }
        .answer-zone {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 10px;
            background: #e0f7fa;
            border-radius: 10px;
        }
        .answer-slot {
            width: 65px;
            height: 85px;
            border: 2px dashed #007bff;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #007bff;
            background: #fff;
            position: relative;
        }
        .answer-slot.over {
            background: #cceeff;
            border-style: solid;
        }
        .hand-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 20px;
            min-height: 200px;
        }
        .card {
            border: 1px solid #eee;
            border-radius: 6px;
            height: 60px;
            display: flex;
            justify-content: center; 
            align-items: center; 
            font-size: 1.8em;
            font-weight: bold;
            background: none;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: none;
            color: #333;
            padding: 5px; 
            cursor: grab;
            touch-action: none;
        }
        .card:active {
            cursor: grabbing;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            background: #f0f0f0;
        }
        .card.dragging {
            position: fixed; 
            z-index: 1000;  
            opacity: 0.8;
            pointer-events: none; 
        }
        .card sup {
            font-size: 0.6em; 
            line-height: 0; 
            position: relative; 
            top: -0.7em; 
            left: 0.1em; 
            pointer-events: none; 
        }
        .card.placed {
            background: none;
            border-color: #eee;
        }
        .finish-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            margin-top: 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .finish-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .modal {
            display: none; 
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 12px;
            text-align: center;
        }
        .modal-content h2 { color: #005a9c; }
        .modal-content ol { text-align: left; line-height: 1.8; }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .game-container {
                flex-direction: column; 
                align-items: center;
            }
            .player-zone {
                width: 95%; 
                max-width: unset; 
            }
            .hand-grid {
                grid-template-columns: repeat(3, 1fr); 
                gap: 8px;
            }
            .card {
                height: 55px;
                font-size: 1.6em;
            }
            .answer-slot {
                width: 55px;
                height: 75px;
                font-size: 1.3em;
            }
        }
        .modal-content.chance-card-content {
            background: linear-gradient(135deg, #fff7b0, #ffca5c);
            border: 3px solid #f7971e;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .modal-content.chance-card-content h2 {
            color: #e65100; 
            text-shadow: 1px 1px 0px #fff;
        }
        #draw-chance-card-btn,
        #continue-game-btn {
            background-color: #f57f17; 
            color: white;
            font-size: 1.2em;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 15px;
        }
        #draw-chance-card-btn:hover,
        #continue-game-btn:hover {
            background-color: #e65100; 
        }
        #chance-card-result h3 {
            font-size: 1.5em;
            color: #d9534f; 
            margin-top: 20px;
            margin-bottom: 5px;
        }
        #chance-card-result p {
            font-size: 1.1em;
            font-weight: bold;
        }
    </style>
    </head>
<body>

    <div class="game-container">
        <div class="controls">
            <h2>公因數 & 公倍數PK賽</h2>
            <button id="start-round-btn">開始回合</button>
            <div class="problem-type-display">
                題目: <span id="problem-type">--</span>
            </div>
            <div class="round-display">
                第 <span id="round-number">1</span> / 5 回合
            </div>
            <div class="round-config">
                <label for="max-rounds-select">設定回合數: </label>
                <select id="max-rounds-select">
                    <option value="3">3 回合 (快速)</option>
                    <option value="5" selected>5 回合 (標準)</option>
                    <option value="7">7 回合 (進階)</option>
                    <option value="10">10 回合 (完整)</option>
                    <option value="1">1 回合 (測試用)</option>
                </select>
            </div>
            <button id="show-rules-btn">顯示規則</button>
        </div>

        <div class="player-zone" id="player-A">
            <h3>玩家 A</h3>
            <div class="problem-display" id="problem-A"></div>
            <div class="timer-display">計時: <span id="timer-A">0:00</span></div>
            <div class="score-display">分數: <span id="score-A">0</span></div>
            
            <div class="answer-zone" id="answer-zone-A">
                <div class="answer-slot" data-base="2">2</div>
                <div class="answer-slot" data-base="3">3</div>
                <div class="answer-slot" data-base="5">5</div>
                <div class="answer-slot" data-base="7">7</div>
                <div class="answer-slot" data-base="11">11</div>
            </div>
            <div class="hand-grid" id="hand-grid-A"></div>
            <button class="finish-btn" id="finish-btn-A" disabled>完成作答</button>
        </div>

        <div class="player-zone" id="player-B">
            <h3>玩家 B</h3>
            <div class="problem-display" id="problem-B"></div>
            <div class="timer-display">計時: <span id="timer-B">0:00</span></div>
            <div class="score-display">分數: <span id="score-B">0</span></div>

            <div class="answer-zone" id="answer-zone-B">
                <div class="answer-slot" data-base="2">2</div>
                <div class="answer-slot" data-base="3">3</div>
                <div class="answer-slot" data-base="5">5</div>
                <div class="answer-slot" data-base="7">7</div>
                <div class="answer-slot" data-base="11">11</div>
            </div>
            <div class="hand-grid" id="hand-grid-B"></div>
            <button class="finish-btn" id="finish-btn-B" disabled>完成作答</button>
        </div>
    </div>

    <div id="rules-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <h2>遊戲規則 (V4.0)</h2>
            <ol>
                <li>每回合限時 60 秒，超時該回合 0 分。</li>
                <li>15 秒內答對得 4 分。</li>
                <li>30 秒內答對得 3 分。</li>
                <li>45 秒內答對得 2 分。</li>
                <li>60 秒內答對得 1 分。</li>
                <li>在指定回合結束後，分數落後者可抽機會卡。</li>
                <li>最終回合完成，統計總分。</li>
            </ol>
        </div>
    </div>

    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2>遊戲結束!</h2>
            <p id="winner-message"></p>
            <button id="restart-game-btn">重新開始</button>
        </div>
    </div>

    <div id="chance-card-modal" class="modal">
        <div class="modal-content chance-card-content">
            <h2>✨ 機會卡 ✨</h2>
            <p id="chance-card-player">輪到「玩家 X」抽卡！</p>
            <p>請抽一張卡，平衡戰局！</p>
            <button id="draw-chance-card-btn">抽卡</button>
            <div id="chance-card-result" style="display: none;">
                <h3 id="chance-card-effect-name"></h3>
                <p id="chance-card-effect-desc"></p>
                <button id="continue-game-btn">繼續遊戲</button>
            </div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 全局變數和 DOM 元素 ---
            const BASES = [2, 3, 5, 7, 11];
            const MAX_POWER = 4;
            let MAX_ROUNDS = 5; 
            const TIME_LIMIT_SECONDS = 60; 
            
            const MASTER_CARD_LIST = [];
            MASTER_CARD_LIST.push({ base: 1, power: 0 }); 
            BASES.forEach(base => {
                for (let power = 1; power <= MAX_POWER; power++) {
                    MASTER_CARD_LIST.push({ base, power });
                }
            });

            const CHANCE_CARDS = [
                { id: "scoreSwap", name: "風水輪流轉！", desc: "雙方分數互換！" },
                { id: "scoreThief", name: "分數小偷", desc: "從對手那裡偷 2 分！" },
                { id: "catchUp", name: "迎頭趕上", desc: "自己直接加 3 分！" },
                { id: "doublePoints", name: "決戰時刻！", desc: "下一回合的分數加倍！" }
            ];
            let currentChanceEffect = null; 

            let gameState = {
                round: 1,
                problemMode: 'gcd',
                problemA: [],
                problemB: [],
                correctAnswer: [],
                timers: { A: null, B: null },
                scores: { A: 0, B: 0 },
                timeElapsed: { A: 0, B: 0 },
                finished: { A: false, B: false },
                isDoublePoints: false
            };
            
            // 【V4.0 修正】 用一個物件來追蹤所有 "正在拖曳" 的卡片
            // Key 可以是 "mouse" 或 觸控的 identifier
            // Value 是 { card, offsetX, offsetY, originalParent }
            let activeDrags = {};

            // DOM 元素
            const startRoundBtn = document.getElementById('start-round-btn');
            const problemTypeDisplay = document.getElementById('problem-type');
            const roundNumberDisplay = document.getElementById('round-number');
            const maxRoundsSelect = document.getElementById('max-rounds-select');
            
            const elementsA = {
                problem: document.getElementById('problem-A'),
                timer: document.getElementById('timer-A'),
                score: document.getElementById('score-A'),
                answerZone: document.getElementById('answer-zone-A'),
                handGrid: document.getElementById('hand-grid-A'),
                finishBtn: document.getElementById('finish-btn-A'),
                answerSlots: document.querySelectorAll('#answer-zone-A .answer-slot')
            };
            
            const elementsB = {
                problem: document.getElementById('problem-B'),
                timer: document.getElementById('timer-B'),
                score: document.getElementById('score-B'),
                answerZone: document.getElementById('answer-zone-B'),
                handGrid: document.getElementById('hand-grid-B'),
                finishBtn: document.getElementById('finish-btn-B'),
                answerSlots: document.querySelectorAll('#answer-zone-B .answer-slot')
            };
            const allAnswerSlots = document.querySelectorAll('.answer-slot'); 

            // 規則彈窗
            const rulesModal = document.getElementById('rules-modal');
            const showRulesBtn = document.getElementById('show-rules-btn');
            const closeBtn = rulesModal.querySelector('.close-btn'); 
            showRulesBtn.onclick = () => rulesModal.style.display = 'block';
            closeBtn.onclick = () => rulesModal.style.display = 'none';
            window.onclick = (event) => {
                if (event.target == rulesModal) rulesModal.style.display = 'none';
            };

            // 遊戲結束彈窗
            const gameOverModal = document.getElementById('game-over-modal');
            const winnerMessage = document.getElementById('winner-message');
            const restartGameBtn = document.getElementById('restart-game-btn');
            restartGameBtn.onclick = resetGame; 

            // 機會卡彈窗 DOM
            const chanceCardModal = document.getElementById('chance-card-modal');
            const chanceCardPlayer = document.getElementById('chance-card-player');
            const drawChanceCardBtn = document.getElementById('draw-chance-card-btn');
            const chanceCardResult = document.getElementById('chance-card-result');
            const chanceCardEffectName = document.getElementById('chance-card-effect-name');
            const chanceCardEffectDesc = document.getElementById('chance-card-effect-desc');
            const continueGameBtn = document.getElementById('continue-game-btn');

            // --- 事件監聽 ---
            startRoundBtn.addEventListener('click', startRound);
            elementsA.finishBtn.addEventListener('click', () => finishRound('A'));
            elementsB.finishBtn.addEventListener('click', () => finishRound('B'));
            drawChanceCardBtn.addEventListener('click', drawChanceCard);
            continueGameBtn.addEventListener('click', applyEffectAndContinue);
            
            // --- 【V4.0】拖曳邏輯 (滑鼠 + 觸控) ---
            function initializeGame() {
                // 監聽 "按下"
                document.body.addEventListener('mousedown', dragStart);
                document.body.addEventListener('touchstart', dragStart, { passive: false });

                // 監聽 "移動"
                document.body.addEventListener('mousemove', dragMove);
                document.body.addEventListener('touchmove', dragMove, { passive: false });
                
                // 監聽 "放開"
                document.body.addEventListener('mouseup', dragEnd);
                document.body.addEventListener('touchend', dragEnd);
                document.body.addEventListener('touchcancel', dragEnd); // 把 "取消" 也當作 "放開"
                
                resetGame(); 
            }

            // 【V4.0】當 "按下" (滑鼠或手指)
            function dragStart(e) {
                const card = e.target.closest('.card');
                if (!card) return;
                if (startRoundBtn.disabled === false) return;
                
                // 阻止預設行為 (例如長按選取文字或滾動)
                e.preventDefault();

                // 記錄卡片原始的家 (手牌區 或是 某個答案格)
                const originalParent = card.parentElement;
                
                if (e.type === 'mousedown') {
                    // --- 滑鼠按下 ---
                    const touch = e;
                    const rect = card.getBoundingClientRect();
                    activeDrags['mouse'] = {
                        card: card,
                        offsetX: touch.clientX - rect.left,
                        offsetY: touch.clientY - rect.top,
                        originalParent: originalParent
                    };
                } else {
                    // --- 手指觸控 ---
                    // 遍歷所有 "剛按下" 的手指
                    for (let touch of e.changedTouches) {
                        const rect = card.getBoundingClientRect();
                        activeDrags[touch.identifier] = {
                            card: card,
                            offsetX: touch.clientX - rect.left,
                            offsetY: touch.clientY - rect.top,
                            originalParent: originalParent
                        };
                    }
                }
                
                // 讓卡片浮動
                card.classList.add('dragging');
                card.style.width = card.offsetWidth + 'px';
                card.style.height = card.offsetHeight + 'px';
                
                const firstTouch = e.touches ? e.touches[0] : e;
                moveCard(card, firstTouch.clientX, firstTouch.clientY, activeDrags[e.touches ? e.touches[0].identifier : 'mouse']);
                
                // 如果卡片是從 answer-slot 拖出來的，清空該 slot
                const parentSlot = card.closest('.answer-slot');
                if (parentSlot) {
                    parentSlot.classList.remove('filled');
                    parentSlot.innerHTML = parentSlot.dataset.base; 
                }
            }

            // 【V4.0】 helper 函數：移動卡片
            function moveCard(card, x, y, dragData) {
                if (!card || !dragData) return;
                card.style.left = (x - dragData.offsetX) + 'px';
                card.style.top = (y - dragData.offsetY) + 'px';
            }

            // 【V4.0】當 "移動" (滑鼠或手指)
            function dragMove(e) {
                if (Object.keys(activeDrags).length === 0) return;
                e.preventDefault();

                if (e.type === 'mousemove') {
                    // --- 滑鼠移動 ---
                    const dragData = activeDrags['mouse'];
                    if (!dragData) return;
                    
                    moveCard(dragData.card, e.clientX, e.clientY, dragData);
                    checkOverSlot(dragData.card, e.clientX, e.clientY);

                } else {
                    // --- 手指移動 ---
                    // 遍歷所有 "正在移動" 的手指
                    for (let touch of e.changedTouches) {
                        const dragData = activeDrags[touch.identifier];
                        if (!dragData) continue; // 這根手指不是在拖曳卡片
                        
                        moveCard(dragData.card, touch.clientX, touch.clientY, dragData);
                        checkOverSlot(dragData.card, touch.clientX, touch.clientY);
                    }
                }
            }

            // 【V4.0】 helper 函數：檢查是否停在 slot 上方
            function checkOverSlot(card, x, y) {
                // 1. 隱藏卡片, 偵測下方元素
                card.style.display = 'none';
                const elementBelow = document.elementFromPoint(x, y);
                card.style.display = ''; 

                // 2. 清除所有 .over 狀態
                allAnswerSlots.forEach(s => s.classList.remove('over'));

                // 3. 檢查下方元素是不是 slot
                const slotBelow = elementBelow ? elementBelow.closest('.answer-slot') : null;
                if (slotBelow) {
                    // 檢查是否為 "同一個玩家" 的 slot
                    const cardPlayerZone = card.closest('.player-zone');
                    const slotPlayerZone = slotBelow.closest('.player-zone');
                    if (cardPlayerZone && slotPlayerZone && cardPlayerZone.id === slotPlayerZone.id) {
                        slotBelow.classList.add('over');
                    }
                }
            }


            // 【V4.0】當 "放開" (滑鼠或手指)
            function dragEnd(e) {
                if (Object.keys(activeDrags).length === 0) return;
                e.preventDefault();
                
                if (e.type === 'mouseup') {
                    // --- 滑鼠放開 ---
                    const dragData = activeDrags['mouse'];
                    if (!dragData) return;
                    
                    dropCard(dragData.card, e.clientX, e.clientY, dragData.originalParent);
                    delete activeDrags['mouse'];
                
                } else {
                    // --- 手指放開 (touchend or touchcancel) ---
                    for (let touch of e.changedTouches) {
                        const dragData = activeDrags[touch.identifier];
                        if (!dragData) continue; // 這根手指不是在拖曳卡片
                        
                        // 檢查是 "正常放開" 還是 "被取消"
                        if (e.type === 'touchcancel') {
                            // 被取消 (例如多點觸控)，無條件送回原位
                            putCardBack(dragData.card, dragData.originalParent);
                        } else {
                            // 正常放開，檢查掉落位置
                            dropCard(dragData.card, touch.clientX, touch.clientY, dragData.originalParent);
                        }
                        
                        delete activeDrags[touch.identifier];
                    }
                }
            }

            // 【V4.0】 helper 函數：處理卡片掉落
            function dropCard(card, x, y, originalParent) {
                // 1. 偵測下方元素
                card.style.display = 'none';
                const elementBelow = document.elementFromPoint(x, y);
                card.style.display = ''; 

                allAnswerSlots.forEach(s => s.classList.remove('over'));

                // 2. 恢復卡片樣式
                card.classList.remove('dragging');
                card.style.position = '';
                card.style.zIndex = '';
                card.style.left = '';
                card.style.top = '';
                card.style.width = '';
                card.style.height = '';

                // --- 判斷掉落在哪裡 ---
                const slotBelow = elementBelow ? elementBelow.closest('.answer-slot') : null;
                const cardPlayerZone = card.closest('.player-zone'); 
                const originalHandGrid = cardPlayerZone.id === 'player-A' ? elementsA.handGrid : elementsB.handGrid;

                // 判斷 1: 是否掉在一個 "slot" 上？
                if (slotBelow) {
                    const slotPlayerZone = slotBelow.closest('.player-zone');
                    const cardBase = card.dataset.base;
                    const slotBase = slotBelow.dataset.base;

                    // 判斷 2: 是否為 "同一個玩家" 的 "正確 slot"？
                    if (cardPlayerZone && slotPlayerZone && cardPlayerZone.id === slotPlayerZone.id && (cardBase == 1 || cardBase == slotBase)) {
                        
                        // 檢查 slot 是否已滿
                        if (slotBelow.classList.contains('filled')) {
                            // 把舊的卡片踢回手牌區
                            originalHandGrid.appendChild(slotBelow.querySelector('.card'));
                        }
                        
                        slotBelow.innerHTML = ''; 
                        slotBelow.appendChild(card);
                        slotBelow.classList.add('filled');
                        card.classList.add('placed');
                    } else {
                        // 放錯 slot (不同玩家 或 不同 base)，送回原位
                        putCardBack(card, originalParent);
                    }
                } else {
                    // 判斷 2: 不是掉在 slot 上 (例如掉回手牌區)，送回原位
                    putCardBack(card, originalParent);
                }

                // 檢查是否 5 格都滿了
                if (cardPlayerZone.id === 'player-A') {
                    checkAllSlotsFilled(elementsA.answerSlots, elementsA.finishBtn);
                } else {
                    checkAllSlotsFilled(elementsB.answerSlots, elementsB.finishBtn);
                }
            }
            
            // 【V4.0】 helper 函數：把卡片放回原位
            function putCardBack(card, originalParent) {
                if (originalParent.classList.contains('answer-slot')) {
                    // 如果原位是答案格
                    originalParent.innerHTML = '';
                    originalParent.appendChild(card);
                    originalParent.classList.add('filled');
                } else {
                    // 如果原位是手牌區
                    originalParent.appendChild(card);
                }
            }


            // --- 舊有邏輯 (不變) ---

            function startRound() {
                if (gameState.round === 1) {
                    MAX_ROUNDS = parseInt(maxRoundsSelect.value);
                    maxRoundsSelect.disabled = true;
                }
                resetRoundState();

                gameState.problemMode = Math.random() < 0.5 ? 'gcd' : 'lcm';
                problemTypeDisplay.textContent = gameState.problemMode === 'gcd' ? '最大公因數' : '最小公倍數';
                roundNumberDisplay.textContent = `${gameState.round} / ${MAX_ROUNDS}`;
                
                if (gameState.isDoublePoints) {
                    problemTypeDisplay.textContent += " (分數加倍!)";
                }

                gameState.problemA = generateProblemPowers();
                gameState.problemB = generateProblemPowers();
                gameState.correctAnswer = calculateAnswer(gameState.problemA, gameState.problemB, gameState.problemMode);

                renderProblem(elementsA.problem, gameState.problemA, "A");
                renderProblem(elementsB.problem, gameState.problemB, "B");
                renderHand(elementsA.handGrid, gameState.correctAnswer, 'A');
                renderHand(elementsB.handGrid, gameState.correctAnswer, 'B');

                startTimer('A');
                startTimer('B');
            }

            function resetRoundState() {
                startRoundBtn.disabled = true;
                startRoundBtn.textContent = '回合進行中...';
                
                gameState.finished = { A: false, B: false };
                gameState.timeElapsed = { A: 0, B: 0 };
                
                if (gameState.timers.A) clearInterval(gameState.timers.A);
                if (gameState.timers.B) clearInterval(gameState.timers.B);
                
                elementsA.timer.textContent = '0:00';
                elementsB.timer.textContent = '0:00';
                elementsA.timer.style.color = '#333';
                elementsB.timer.style.color = '#333';

                elementsA.problem.innerHTML = '出題中...';
                elementsB.problem.innerHTML = '出題中...';
                elementsA.handGrid.innerHTML = '';
                elementsB.handGrid.innerHTML = '';
                elementsA.answerSlots.forEach(slot => {
                    slot.innerHTML = slot.dataset.base;
                    slot.classList.remove('filled');
                    if(slot.querySelector('.card')) slot.removeChild(slot.querySelector('.card'));
                });
                elementsB.answerSlots.forEach(slot => {
                    slot.innerHTML = slot.dataset.base;
                    slot.classList.remove('filled');
                    if(slot.querySelector('.card')) slot.removeChild(slot.querySelector('.card'));
                });
                
                elementsA.finishBtn.disabled = true;
                elementsB.finishBtn.disabled = true;
            }

            function generateProblemPowers() {
                let powers = [];
                for (let i = 0; i < BASES.length; i++) {
                    powers.push(Math.floor(Math.random() * (MAX_POWER + 1)));
                }
                return powers;
            }
            
            function renderProblem(element, powers, playerLabel) {
                element.innerHTML = `<strong>${playerLabel} 的數字:</strong> `;
                powers.forEach((power, index) => {
                    const base = BASES[index];
                    element.innerHTML += `
                        <span class="problem-item">
                            <span class="base">${base}</span>
                            <sup class="power">${power}</sup>
                        </span>
                        ${index < BASES.length - 1 ? ' &times; ' : ''}
                    `;
                });
            }

            function calculateAnswer(powersA, powersB, mode) {
                let answerPowers = [];
                for (let i = 0; i < BASES.length; i++) {
                    if (mode === 'gcd') {
                        answerPowers.push(Math.min(powersA[i], powersB[i]));
                    } else { // lcm
                        answerPowers.push(Math.max(powersA[i], powersB[i]));
                    }
                }
                return answerPowers;
            }

            function renderHand(handGridElement, answerPowers, player) {
                let answerCards = [];
                answerPowers.forEach((power, index) => {
                    if (power === 0) {
                        answerCards.push({ base: 1, power: 0 });
                    } else {
                        answerCards.push({ base: BASES[index], power: power });
                    }
                });

                let distractorPool = MASTER_CARD_LIST.filter(masterCard => {
                    return !answerCards.some(ansCard => 
                        ansCard.base === masterCard.base && ansCard.power === masterCard.power
                    );
                });
                distractorPool.sort(() => Math.random() - 0.5);

                let handCards = [...answerCards];
                while (handCards.length < 16 && distractorPool.length > 0) {
                    handCards.push(distractorPool.pop());
                }
                while (handCards.length < 16) {
                    handCards.push(MASTER_CARD_LIST[Math.floor(Math.random() * MASTER_CARD_LIST.length)]);
                }

                handCards.sort(() => Math.random() - 0.5);

                handCards.forEach((card, i) => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'card';
                    cardElement.id = `card-${player}-${i}`;
                    cardElement.dataset.base = card.base;
                    cardElement.dataset.power = card.power;
                    
                    if (card.base === 1) {
                        cardElement.innerHTML = `1`;
                    } else {
                        cardElement.innerHTML = `${card.base}<sup>${card.power}</sup>`;
                    }
                    
                    handGridElement.appendChild(cardElement);
                });
            }
            
            function startTimer(player) {
                gameState.timeElapsed[player] = 0;
                const timerElement = (player === 'A') ? elementsA.timer : elementsB.timer;
                
                timerElement.style.color = '#333'; 

                gameState.timers[player] = setInterval(() => {
                    if (gameState.finished[player]) {
                        clearInterval(gameState.timers[player]);
                        return;
                    }

                    gameState.timeElapsed[player]++;
                    
                    if (gameState.timeElapsed[player] > TIME_LIMIT_SECONDS) {
                        clearInterval(gameState.timers[player]);
                        timerElement.textContent = "1:00 (時間到!)";
                        timerElement.style.color = '#d9534f'; 
                        finishRound(player); 
                        return;
                    }
                    
                    const minutes = Math.floor(gameState.timeElapsed[player] / 60);
                    const seconds = gameState.timeElapsed[player] % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                }, 1000);
            }
            
            function checkAllSlotsFilled(answerSlots, finishBtn) {
                let allFilled = true;
                answerSlots.forEach(slot => {
                    if (!slot.classList.contains('filled')) {
                        allFilled = false;
                    }
                });
                finishBtn.disabled = !allFilled; 
            }
            
            function finishRound(player) {
                if (gameState.finished[player]) return; 

                clearInterval(gameState.timers[player]);
                gameState.finished[player] = true;
                const elements = (player === 'A') ? elementsA : elementsB;
                elements.finishBtn.disabled = true;

                let isCorrect = true;
                
                if (gameState.timeElapsed[player] <= TIME_LIMIT_SECONDS) {
                    elements.answerSlots.forEach((slot, index) => {
                        const card = slot.querySelector('.card');
                        if (!card) {
                            isCorrect = false;
                            return;
                        }
                        const correctPower = gameState.correctAnswer[index];
                        const cardBase = card.dataset.base;
                        const cardPower = card.dataset.power;

                        if (correctPower == 0) {
                            if (cardBase != 1) isCorrect = false;
                        } else {
                            const correctBase = BASES[index];
                            if (cardBase != correctBase || cardPower != correctPower) {
                                isCorrect = false;
                            }
                        }
                    });
                } else {
                    isCorrect = false;
                }

                // V2.2 新計分規則
                let scoreEarned = 0;
                if (isCorrect) {
                    const time = gameState.timeElapsed[player];
                    if (time <= 15) {
                        scoreEarned = 4;
                    } else if (time <= 30) {
                        scoreEarned = 3;
                    } else if (time <= 45) {
                        scoreEarned = 2;
                    } else { // 46-60 秒
                        scoreEarned = 1;
                    }

                    if (gameState.isDoublePoints) {
                        scoreEarned *= 2;
                    }
                }
                
                gameState.scores[player] += scoreEarned;
                elements.score.textContent = gameState.scores[player];
                
                if (gameState.finished.A && gameState.finished.B) {
                    gameState.isDoublePoints = false;
                    if (shouldTriggerChanceCard()) {
                        showChanceCardModal();
                    } else {
                        proceedToNextRound();
                    }
                }
            }

            function shouldTriggerChanceCard() {
                const round = gameState.round;
                const max = MAX_ROUNDS;
                if (gameState.scores.A === gameState.scores.B || round === max) {
                    return false;
                }
                if (max === 3 && round === 2) return true;
                if (max === 5 && round === 3) return true;
                if (max === 7 && round === 4) return true;
                if (max === 10 && (round === 4 || round === 8)) return true;
                return false;
            }
            
            function showChanceCardModal() {
                const losingPlayer = (gameState.scores.A < gameState.scores.B) ? 'A' : 'B';
                chanceCardPlayer.textContent = `輪到「玩家 ${losingPlayer}」抽卡！`;
                chanceCardResult.style.display = 'none';
                drawChanceCardBtn.style.display = 'block';
                chanceCardModal.style.display = 'block';
            }

            function drawChanceCard() {
                currentChanceEffect = CHANCE_CARDS[Math.floor(Math.random() * CHANCE_CARDS.length)];
                chanceCardEffectName.textContent = currentChanceEffect.name;
                chanceCardEffectDesc.textContent = currentChanceEffect.desc;
                drawChanceCardBtn.style.display = 'none';
                chanceCardResult.style.display = 'block';
            }

            function applyEffectAndContinue() {
                const effectId = currentChanceEffect.id;
                const { A, B } = gameState.scores;

                if (effectId === 'scoreSwap') {
                    gameState.scores = { A: B, B: A };
                } 
                else if (effectId === 'scoreThief') {
                    if (A < B) { // A 落後
                        gameState.scores = { A: A + 2, B: Math.max(0, B - 2) }; 
                    } else { // B 落後
                        gameState.scores = { A: Math.max(0, A - 2), B: B + 2 }; 
                    }
                }
                else if (effectId === 'catchUp') {
                    if (A < B) { // A 落後
                        gameState.scores.A += 3;
                    } else { // B 落後
                        gameState.scores.B += 3;
                    }
                }
                else if (effectId === 'doublePoints') {
                    gameState.isDoublePoints = true; 
                }

                elementsA.score.textContent = gameState.scores.A;
                elementsB.score.textContent = gameState.scores.B;

                chanceCardModal.style.display = 'none';
                proceedToNextRound();
            }
            
            function proceedToNextRound() {
                if (gameState.round < MAX_ROUNDS) {
                    gameState.round++;
                    startRoundBtn.disabled = false;
                    startRoundBtn.textContent = `開始第 ${gameState.round} 回合`;
                } else {
                    endGame();
                }
            }

            function endGame() {
                gameOverModal.style.display = 'block';
                if (gameState.scores.A > gameState.scores.B) {
                    winnerMessage.textContent = `玩家 A 獲勝！ (${gameState.scores.A} vs ${gameState.scores.B})`;
                } else if (gameState.scores.B > gameState.scores.A) {
                    winnerMessage.textContent = `玩家 B 獲勝！ (${gameState.scores.B} vs ${gameState.scores.A})`;
                } else {
                    winnerMessage.textContent = `平手！ (${gameState.scores.A} vs ${gameState.scores.B})`;
                }
            }

            function resetGame() {
                gameState.round = 1;
                gameState.scores = { A: 0, B: 0 };
                gameState.finished = { A: false, B: false };
                gameState.isDoublePoints = false;
                activeDrags = {}; // 【V4.0 修正】
                if (gameState.timers.A) clearInterval(gameState.timers.A);
                if (gameState.timers.B) clearInterval(gameState.timers.B);

                elementsA.score.textContent = '0';
                elementsB.score.textContent = '0';
                elementsA.timer.textContent = '0:00';
                elementsB.timer.textContent = '0:00';
                elementsA.timer.style.color = '#333';
                elementsB.timer.style.color = '#333';
                elementsA.problem.innerHTML = '';
                elementsB.problem.innerHTML = '';
                elementsA.handGrid.innerHTML = '';
                elementsB.handGrid.innerHTML = '';
                
                elementsA.answerSlots.forEach(slot => {
                    slot.innerHTML = slot.dataset.base;
                    slot.classList.remove('filled');
                });
                elementsB.answerSlots.forEach(slot => {
                    slot.innerHTML = slot.dataset.base;
                    slot.classList.remove('filled');
                });
                
                elementsA.finishBtn.disabled = true;
                elementsB.finishBtn.disabled = true;

                startRoundBtn.disabled = false;
                startRoundBtn.textContent = '開始回合';
                maxRoundsSelect.disabled = false; 
                
                MAX_ROUNDS = parseInt(maxRoundsSelect.value); 
                roundNumberDisplay.textContent = `1 / ${MAX_ROUNDS}`;
                problemTypeDisplay.textContent = '--';
                
                gameOverModal.style.display = 'none';
                chanceCardModal.style.display = 'none';
            }

            // --- 啟動遊戲 ---
            initializeGame();

        });
    </script>
    </body>
</html>
